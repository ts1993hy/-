# JIT（动态编译）和AOT（静态编译）编译技术比较

> Java的初衷：一次编译，随处运行。（不忘初心，继续前行。）

因此Java一直致力于在不牺牲平台无关性的情况下实现本地编译的性能。

> 编译和解释的对比

显然编译后执行的效率要远远高于解释执行的效率，但是这并不代表编译这个过程比较快（比如编译Linux内核就贼慢）。因此在追求启动速度上，解释执行自然要优于编译执行。不过编译的效率确实贼高，因此JIT便应运而生。但是解释也有其优点，因为编译后的代码量是原来代码量的１０余倍还要多。

## JIT出现之前

早期的JRE通过解释字节码来执行Java程序。即JVM在一个循环中重复操作：

1. 获取待执行的下一个字节码
1. 解码
1. 从操作数堆栈获取所需的操作数
1. 按照JVM规范执行操作
1. 将结果写回堆栈

这种方法的优点是其简单性：
JRE开发人员只需要编写代码来处理每种字节码即可。并且因为用于描述操作的字节码少于255个，所以实现的成本比较低。这种方法的缺点是性能。

## JIT的出现

直到JDK1.2，JIT才现身了。值得注意的是JIT编译保持了平台无关性，但是也付出了一些代价。因为在程序执行时进行编译，所以编译代码的时间将计入程序的执行时间。如同之前提到的，编译往往是比较慢的。

JIT编译器在运行程序时有两种编译模式可以选择，并且其会在运行时决定使用哪一种以达到最佳性能。这两种编译模式的命名源自于命令行参数（-client或者-server）。最主要的差别在于：-server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。（在虚拟机运行在-client模式的时候，使用的是一个代号为C1的轻量级编译器，而-server模式启动的虚拟机采用相对重量级代号为C2的编译器。C2比C1编译器编译的相对彻底，服务运行起来之后，性能更高。）

> `java -version`命令行可以直接查看当前系统使用的是client还是server模式。

## 编译器调优

### 初级编译器调优

大多数情况下，优化编译器其实只是选择何时的JVM以及为目标主机选择合适的编译器（-client，-server或是-xx:+TieredCompilation）。多层编译经常是长时间运行应用程序的最佳选择，短暂应用程序则选择毫秒级性能的client编译器。

> 分层编译（-XX:+TieredCompilation）是jvm在jdk6u25之后引入的。它是一种折中，在系统执行初期，执行频率比较高的代码先被c1编译器编译，以便尽快进入编译执行，然后随着时间的推移，执行频率比较高的代码再被c2编译器编译，以达到最高的性能。

### 中级编译器调优

#### 优化代码缓存

当JVM编译代码时，它会将汇编指令集保存在代码缓存。代码缓存具有固定的大小，并且一旦它被填满，JVM则不能再编译更多的代码。（当使用普通server编译器模式时，编译合格的类的数量将被填入代码缓存，通常只有少量的类会被编译。但是当使用client编译器模式时，编译合格的类的数量将会高很多。）

这个具有一个潜在的问题。有些热点代码将会被编译，而其他的则不会被编译，这个应用程序将会以运行大量的解释代码来结束。

在Java 7中，分层编译默认的代码缓存经常是不够的，需要经常提高代码缓存大小。大型项目若使用client编译器模式，则也需要提高代码缓存大小。现在并没有一个好的机制可以确定一个特定的应用到底需要多大的代码缓存。因此，当需要提高代码缓存时，这将是一种凑巧的操作，一个通常的做法是将代码缓存变成默认大小的两倍或四倍。

可以通过 -XX:ReservedCodeCacheSize=Nflag（N就是之前提到的默认大小）来最大化代码缓存大小。代码缓存的管理类似于JVM中的内存管理：有一个初始大小（用-XX:InitialCodeCacheSize=N来声明）。代码缓存的大小从初始大小是基于芯片架构以及使用的编译器的，重新定义代码缓存的大小并不会真正影响性能，所以设置ReservedCodeCacheSize的大小一般是必要的。

而且，如果JVM是32位的，那么运行过程大小不能超过4GB。这包括了Java堆，JVM自身所有的代码空间（包括其自身的库和线程栈），应用程序分配的任何的本地内存，当然还有代码缓存。所以，代码缓存并不是无限的，很多时候需要为大型应用程序来调优（或者甚至是使用`分层编译`的中型应用程序）。比如64位机器，为代码缓存设置一个很大的值并不会对应用程序本身造成影响，应用程序并不会内存溢出，这些额外的内存预定一般都是被操作系统所接受的。

#### 编译阈值

在JVM中，编译是基于两个计数器的：一个是被调用的次数，另一个是方法中被回弹的次数。（回弹可以有效的被认为是循环被执行完成的次数。）

当JVM执行一个Java方法，它会检查这两个计数器的总和以决定这个方法是否有资格被编译，如果有，则这个方法将排队等待编译。这种编译形式并没有一个官方的名字，但是一般叫做标准编译。

无论是编译动作是方法触发的还是循环体触发的，都是编译整个方法。（持有保留意见，在IBM的`深入浅出 JIT 编译器`中提到由循环体触发的只是编译整个循环体，暂时无法确定是版本原因还是其他原因）。

在`方法计数器`的不断累加过程中，有一个热度衰减的过程，被称为方法统计的半衰周期。可以使用-XX:-UseCounterDecay来关闭热度衰减。在这种情况下，只要运行时间足够，理论上所有的方法都会被编译成本地代码。（另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。）

与`方法计数器`不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次进入该方法时就会执行标准编译过程。

### 高级编译器调优

当一个方法具有编译资格时，它就会排队等待编译。这个队列是由一个或多个后台线程组成。这就是说编译是一个异步的过程。它允许程序在代码正在编译时继续解释执行。这些队列并不会严格的遵守先进先出原则：哪一个方法的调用计数器更高，哪一个就拥有优先权。