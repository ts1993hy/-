# Java内存模型以及happens-before规则

> https://www.jianshu.com/p/d52fea0d6ba5

## 引子

多线程操作很容易出现线程安全问题，在《深入理解Java虚拟机》中可以看到关于线程的定义：

当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。

而出现线程安全的问题一般是因为`主内存`和`工作内存数据`的`不一致性`和`重排序`导致的，而解决线程安全的问题最重要的是理解这两种问题是怎么来的，那么，理解它们的核心在于理解Java内存模型（JMM）。

在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等，另外为了性能优化，还会涉及到编译器指令重排序和处理器指令重排序。

## 内存模型抽象结构

在并发编程中，主要需要解决两个问题：

1. 线程之间如何通信（通过何种机制交换信息，一般是共享内存和消息传递）
1. 线程之间如何完成同步

Java内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量来完成隐式通信。

### 那些是共享变量

在Java程序中所有实例域，静态域和数组元素都是放在堆内存中（所有线程均可访问到，是可以共享的），而局部变量，方法定义参数和异常处理器参数不会在线程间共享。共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题。

### JMM抽象结构模型

CPU的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。因此，共享变量会先放在主存中，每个线程都有输入自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。

![JMM抽象结构模型](images/JMM抽象结构模型.png)

如图所示，线程A和线程B之间要完成通信的话，要经历如下两步：

1. 线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；
1. 线程B从主存中读取最新的共享变量

如果线程A更新数据后并没有及时写回到主存，而此时线程B读到的是过期的数据，这就出现了“脏读”的现象。

### 重排序

一个好的内存模型会放松对处理器和编译器规则的束缚，这就会使得软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。

因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序分为如下三种：

![指令重排序](images/指令重排序.png)

1. 编译器优化的重排序。编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序
1. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
1. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。

如图，1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题。

针对编译器重排序，JMM的编译器重排序规则会禁止一些特定类型的编译器重排序；针对处理器重排序，编译器在生成指令序列的时候会通过插入内存屏障来禁止某些特殊的处理器重排序。

#### 重排序的定义

如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性。这里存在三种情况：

1. 读后写
2. 写后写
3. 写后读

这三种操作都是存在数据依赖性的，如果重排序会对最终执行结果存在影响。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

不过无论怎么重排序，程序的执行结果不能被改变。这就是`as-if-serial`，编译器、runtime和处理器都必须遵守as-if-serial语义。

as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime和处理器为编写单线程程序的程序员创建了一个幻觉：单线程程序是按照程序的顺序来执行的。